##Garbage collector

Из устройства памяти JVM мы знаем, что память разделена на 2 части ```Stack``` и ```Heap```. В ```stack``` хранится 
метаинформация (примитивные типы, классы, методы и т.д.), а в ```heap``` хранятся создаваемые объекты.

Сборщик мусора (Garbage Collector) выполняет всего две задачи, связанные с поиском мусора и его очисткой. 
Для обнаружения мусора существует два подхода:
* Reference counting – учет ссылок;
* Tracing – трассировка.

Для выполнения задание я создал класс (GCTest) в классе был переопределен метод ```finalize```. В методе ```largeNumberOfObjects``` 
создал большое количество объектов с помощью цикла, и условие что каждому четному объекту после инициализации я присваиваю 
null, чтобы GC мог сразу "очистить память от этого объекта" (объект все еще существует в памяти, но на него не указывает ни одна ссылка).

Во втором методе (```twoLinksToOneObject```) я попробовал реализовать другую задачу, когда две ссылки указывают на один объект,
исходя из знаний о GC пока на объект находящийся в ```heap``` указывает хотя бы одна ссылка, то объект не будет удален.

И о последнем задание "Проверить что будет если при финализации снова сделать объект достижимым".
Если тут идется речь об "воскрешенном объекте", то когда сборщик мусора JVM в конечном итоге собирается удалить неиспользуемый 
объект, вызывается метод finalize() объекта. Но если мы заново создадим ссылку на объект в собственном методе finalize() 
объекта, объект можно воскресить. В таких случаях JVM обнаружит, что на объект снова ссылаются, и воздержится от его удаления. 