##Garbage collector

Из устройства памяти JVM мы знаем, что память разделена на 2 части ```Stack``` и ```Heap```. В ```stack``` хранится 
метаинформация (примитивные типы, классы, методы и т.д.), а в ```heap``` хранятся создаваемые объекты.

Сборщик мусора (Garbage Collector) выполняет всего две задачи, связанные с поиском мусора и его очисткой. 
Для обнаружения мусора существует два подхода:
* Reference counting – учет ссылок;
* Tracing – трассировка.

Для выполнения задание я создал класс (GCTest) в классе был переопределен метод ```finalize```. В методе ```largeNumberOfObjects``` 
создал большое количество объектов с помощью цикла. В самом цикле к переменной ``gcTest`` каждый раз (1_000_000 раз) присваивается объект,
который находится в ``heap`` и так каждую итерацию. Но с каждой итерацией объекты в "куче" увеличиваются (ключевое слово ``new`` в этом помогает)
 , но ссылка теряется (т.к. она каждый раз присваивается "новому" объекту). И это позволяет GC "очистить память от этого объекта" (объект все еще существует в памяти, но на него не указывает ни одна ссылка).

Пример логов:
```
Object - 430434 was delete.
Object - 432272 was delete.
Object - 432701 was delete.
Object - 433229 was delete.
Object - 434227 was delete.
Object - 434983 was delete.
Object - 435465 was delete.
Object - 439809 was delete.
```

Во втором методе (```twoLinksToOneObject```) я попробовал реализовать другую задачу, когда две ссылки указывают на один объект,
исходя из знаний о GC пока на объект, находящийся в ```heap```, указывает хотя бы одна ссылка, то объект не будет удален.

Пример логов:
```
Second object - 542851 was delete.
Second object - 541741 was delete.
First object - 540138 was delete.
First object - 538788 was delete.
First object - 537370 was delete.
Second object - 536201 was delete.
```

И о последнем задание "Проверить что будет если при финализации снова сделать объект достижимым".
Если тут идется речь об "воскрешенном объекте", то когда сборщик мусора JVM в конечном итоге собирается удалить неиспользуемый 
объект, вызывается метод finalize() объекта. Но если мы заново создадим ссылку на объект в собственном методе finalize() 
объекта, объект можно воскресить. В таких случаях JVM обнаружит, что на объект снова ссылаются, и воздержится от его удаления. 
```
Immortal::finalize for net.broscorp.gc.Immortal@6e051f31
Press any key...
```