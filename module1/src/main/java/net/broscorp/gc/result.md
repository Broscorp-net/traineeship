#GC
В JVM реализовано 2 вида памяти при выполнении процесса:
__Stack__ и __Heap__.

*Stack* - хранит метаданные, классы и методы. Доступ к этим данным может осуществляться только конкретным потоком.

*Heap* - основной сегмент памяти, где хранятся создаваемые объекты. Доступ к ним может осуществляться любой частью приложения.

Сборщик мусора - механизм, который выполняет 2 задачи:
1. Трассировка - учет "живых" объектов. Если из Корневой точки можно добраться до объекта, то он считается "живым".
Если до объекта нельзя добраться из Корневой точки __(недостижимый объект)__ - то он считается мусором.
2. Учет ссылок - у объекта есть счетчик, который показывает кол-во ссылок на него, при удалении ссылки - счетчик уменьшается.
Если ссылок на объект не осталось __(счетчик равен 0)__, то он считается мусором. 
####Лог с JConsole при создании большого количества объектов и теряя ссылки на них
![Finalize](/Users/mac/IdeaProjects/traineeship/module1/src/main/java/net/broscorp/gc/Screenshot 2020-08-25 at 22.24.32.png)
В логе можно наблюдать, что максимальный размер памяти при выполнении достигал
__приблизительно 395Mb__, но после очистки мусора, размер задействованной памяти сразу же уменьшался до __приблизительно 220Mb__.
Это означает, что __сборщик мусора уничтожает незадействованные объекты__. 

####Лог с JConsole при создании большого количества объектов и воскрешая их в метод finalize() - `объект-зомби`
![Zombie](/Users/mac/IdeaProjects/traineeship/module1/src/main/java/net/broscorp/gc/Screenshot 2020-08-25 at 22.15.38.png)
Из лога видно, что размер памяти не уменьшается, а только увеличивается. Это происходит из-за того,
что при вызове метода finalize() ссылка на текущий объект сохраняется в статическую переменную __list__.
__На объекты остаются ссылки, и они не могут быть удалены сборщиком мусора__.

####Лог с JConsole при создании большого количества объектов, которые ссылаются друг на друга
![Referenced](/Users/mac/IdeaProjects/traineeship/module1/src/main/java/net/broscorp/gc/Screenshot 2020-08-25 at 22.43.12.png)
Из лога видно, что при создании большого кол-ва объектов, которые ссылаются друг на друга
размер используемой памяти увеличивается, но сборщик мусора начинает быструю очистку памяти,
так как это __недостижимые объекты (к ним нет доступа с Корневой точки)__. 

