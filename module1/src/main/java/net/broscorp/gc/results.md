## Результаты выполнения задания на тему "Garbage collection"

При выполнении задания реализованы следующие тестовые методы:  
- тест №1 – циклическое создание 1 млн. объектов с потерей ссылки на объект в каждом цикле;  
- тест №2 – циклическое создание 15 тыс. объектов с присвоением ссылки на каждый объект из созданного в начале метода локального списка;  
- тест №3 – циклическое создание 1 млн. объектов со взаимными ссылками в каждой новой паре объектов;  
- тест №4 – циклическое создание 15 тыс. объектов, в методе finalize() которых создается ссылка на this объект из статического списка;  
- тест №5 – циклическое создание 15 тыс. объектов, в методе finalize() которых создается ссылка на this объект из локального списка, являющего приватным полем объекта.  
  
Кастомные опции JVM, примененные для задания:  
-XX:+UseSerialGC -verbose:gc -Xlog:gc* -Xlog:gc:src/main/java/net/broscorp/gc/gclog  

SerialGC выбран для большей наглядности вызовов метода finalize() и работы GC.  
Вывод логов GC перенаправлен в файл gclog и для каждого теста сохранен в соответствующем файле (gclog_test1, gclog_test2, gclog_test3, gclog_test4, gclog_test5), которые входят в состав пулл-реквеста по заданию.  
Фрагменты консольного вывода для каждого теста сохранены в соответствующих файлах (console_output_test1.txt, console_output_test2.txt, console_output_test3.txt, console_output_test4.txt, console_output_test5.txt), которые входят в состав пулл-реквеста по заданию.  
Тесты выполнялись каждый по отдельности, поскольку общий запуск всего тестового класса приводит к "Exception in thread "main" java.lang.OutOfMemoryError: Java heap space". Успешный запуск всего класса на моей машине возможен при сокращении количества создаваемых объектов в тестах №2, 4 и 5 до 7 тыс.шт. (скриншот графика использования памяти из jconsole для этого случая содержится в файле jcons_testClass.png)

**Тест №1.** Из консольного вывода, лога GC и графика jconsole следует:
- общее количество отработок GC во время работы теста – 342;
- вызов метода finalize() у объектов не зависит от порядка их создания;
- по мере заполнения региона Eden вызывается minor алгоритм (Pause Young) работы GC, который очищает эту область, удаляя часть объектов, а часть объектов перенося в регион Tenured. При этом у удаляемых объектов вызывается метод finalize();
- в случае, если не справляется minor алгоритм (Pause Young), вызывается алгоритм полной очистки (Pause Full), который очищает также и регион Tenured. При этом у удаляемых объектов вызывается метод finalize();
- доступный объем памяти для Heap вырос по мере генерации новых объектов с 123 MB до 1926 MB. При этом график использования памяти имеет вид возрастающей зубчатой кривой.  

**Тест №2.** Создаётся 15 тыс. объектов, поскольку при попытке создания 20 тыс. и больше получаем «Exception in thread "main" java.lang.OutOfMemoryError: Java heap space».  
Из консольного вывода, лога GC и графика jconsole следует, что доступный объем памяти для Heap растет по мере генерации новых объектов с 123 MB до 1966 MB (при этом график использования памяти имеет вид возрастающей кривой без периодического уменьшения как это было в тесте №1).  
Общее количество отработок GC во время работы теста – 14.  
Кроме того, следует отметить, что метод finalize() вызывается при первой сборке мусора после того, как объект становится недостижимым. Поскольку всё время работы теста все объекты достижимы, то мы вообще не видим в распечатке признаков вызовов метода finalize(). Поток исполнения приложения заканчивается раньше, чем GC вызывает этот метод у объектов.  

**Тест №3.** Из консольного вывода, лога GC и графика jconsole следует, что поведение теста относительно использования памяти повторяет тест №1, т.е. попарные ссылки объектов друг на друга не изменяют и не замедляют работу GC.  
Общее количество отработок GC во время работы теста – 335.  

**Тест №4.** Создаётся 15 тыс. объектов, поскольку при попытке создания 20 тыс. и больше получаем «Exception in thread "main" java.lang.OutOfMemoryError: Java heap space».  
Из консольного вывода, лога GC и графика jconsole следует, что поведение теста относительно использования памяти примерно повторяет тест №2, т.е. появление статической ссылки в методе finalize() делает объекты достижимыми из корневого объекта и исключает их удаление GC.  
Общее количество отработок GC во время работы теста – 14.  
Кроме того, заметна ещё одна интересная особенность: распечатка демонстрирует наличие трех отдельных потоков выполнения: потока выполнения основного кода, в котором происходит генерация объектов, потока Finalizer, в котором идет выполнение методов finalize() каждого объекта, и потока, в котором работает GC. Поэтому мы видим, что распечатка строки из основного кода «SIZE OF STATIC LIST = 9842» происходит раньше последующих вызовов метода finalize() других объектов, которые пытается удалить GC (а их потом ещё примерно полторы тысячи), а также печать завершающих строк работы GC происходит вперемежку с продолжающимися вызовами метода finalize() объектов.  

**Тест №5.** Создаётся 15 тыс. объектов, поскольку при попытке создания 20 тыс. и больше получаем «Exception in thread "main" java.lang.OutOfMemoryError: Java heap space».  
Из консольного вывода, лога GC и графика jconsole следует, что поведение теста относительно использования памяти примерно повторяет тесты №2 и №4, т.е. появление локальной ссылки в методе finalize() делает объекты достижимыми из корневого объекта и исключает их удаление GC.  
Общее количество отработок GC во время работы теста – 14.

**Дополнительно можно отметить следующее:**
- метод finalize() класса Object пустой и не выполняет никаких действий. Другие объекты могут переопределять это поведение;  
- метод finalize() никогда не вызывается более одного раза для любого заданного объекта;  
- если подкласс переопределяет finalize(), он должен явно вызвать финализатор суперкласса;
- метод finalize() является deprecated, начиная с Java 9.