## Результаты выполнения задания на тему "Garbage collection"

При выполнении задания реализованы следующие тестовые методы (сначала - на Java 11, потом - на Java 8):  
- тест №1 – циклическое создание 1 млн. (для Java 8 - 100 тыс.) объектов с потерей ссылки на объект в каждом цикле;  
- тест №2 – циклическое создание 15 тыс. (для Java 8 - 3 тыс.) объектов с присвоением ссылки на каждый объект из созданного в начале метода локального списка;  
- тест №3 – циклическое создание 1 млн. (для Java 8 - 100 тыс.) объектов со взаимными ссылками в каждой новой паре объектов;  
- тест №4 – циклическое создание 15 тыс. (для Java 8 - 3 тыс.) объектов, в методе finalize() которых создается ссылка на this объект из статического списка;  
- тест №5 – циклическое создание 15 тыс. (для Java 8 - 3 тыс.) объектов, в методе finalize() которых создается ссылка на this объект из локального списка, являющего приватным полем объекта.  
  
Кастомные опции JVM, примененные для задания:  
для Java 11: -XX:+UseSerialGC -verbose:gc -Xlog:gc* -Xlog:gc:src/main/java/net/broscorp/gc/gclog  
для Java 8: -XX:+UseSerialGC -verbose:gc -XX:+PrintGCDetails -Xloggc:src/main/java/net/broscorp/gc/gclog  

SerialGC выбран для большей наглядности вызовов метода finalize() и работы GC.  
Вывод логов GC перенаправлялся в файл gclog и для каждого теста был сохранен в соответствующем файле (gclog_test1, gclog_test2, gclog_test3, gclog_test4, gclog_test5), которые входят в состав пулл-реквеста по заданию.  
Фрагменты консольного вывода для каждого теста сохранены в соответствующих файлах (console_output_test1.txt, console_output_test2.txt, console_output_test3.txt, console_output_test4.txt, console_output_test5.txt), которые входят в состав пулл-реквеста по заданию.  
Тесты выполнялись каждый по отдельности, поскольку общий запуск всего тестового класса приводит к "Exception in thread "main" java.lang.OutOfMemoryError: Java heap space". Успешный запуск всего класса на моей машине возможен при сокращении количества создаваемых объектов в тестах №2, 4 и 5 до 7 тыс.шт. (скриншот графика использования памяти из jconsole для этого случая содержится в файле jcons_testClass.png)  
К сожалению, я сначала не учел, что необходимо пользоваться Java 8, и проводил эксперименты на Java 11 (для которой и приведены файлы с логами, а также график). При переходе на Java 8 из-за замены метода создания длинной строки в каждом объекте с repeat() на join() время выполнения кода стало значительно дольше.  
В пулл-реквесте окончательный код исправлен на Java 8.

**Тест №1.** Из консольного вывода, лога GC и графика jconsole следует:
- общее количество отработок GC во время работы теста – 342 (для Java 8 - 3179) раз;
- последовательность вызовов метода finalize() у объектов не зависит от порядка их создания;
- по мере заполнения региона Eden вызывается minor алгоритм (происходит Pause Young) работы GC, который очищает эту область, удаляя часть объектов, а часть объектов перенося в регион Tenured. При этом у удаляемых объектов вызывается метод finalize();
- в случае, если не справляется minor алгоритм, вызывается алгоритм полной очистки (происходит Pause Full), который очищает также и регион Tenured. При этом у удаляемых объектов вызывается метод finalize();
- доступный объем памяти для Heap возрастает по мере генерации новых объектов с 123 MB до 1926 MB. При этом график фактического использования памяти имеет вид зубчатой кривой.  

**Тест №2.** Создаётся 15 тыс. объектов (для Java 8 - 3 тыс.).  
Из консольного вывода, лога GC и графика jconsole следует, что доступный объем памяти для Heap растет по мере генерации новых объектов с 123 MB до 1966 MB (при этом график использования памяти имеет вид резко возрастающей кривой).  
Общее количество отработок GC во время работы теста – 14 (для Java 8 - 26) раз.  
Кроме того, следует отметить, что метод finalize() вызывается при первой сборке мусора после того, как объект становится недостижимым. Поскольку всё время работы теста все объекты достижимы, то мы вообще не видим в распечатке признаков вызовов метода finalize(). Поток исполнения приложения заканчивается раньше, чем GC вызывает этот метод у объектов.  

**Тест №3.** Из консольного вывода, лога GC и графика jconsole следует, что поведение теста относительно использования памяти повторяет тест №1, т.е. попарные ссылки объектов друг на друга не изменяют и не замедляют работу GC.  
Общее количество отработок GC во время работы теста – 335 (для Java 8 - 3360) раз.  

**Тест №4.** Создаётся 15 тыс. объектов (для Java 8 - 3 тыс.).  
Из консольного вывода, лога GC и графика jconsole следует, что поведение теста относительно использования памяти примерно повторяет тест №2, т.е. появление статической ссылки в методе finalize() делает объекты достижимыми из корневого объекта и исключает их удаление GC.  
Общее количество отработок GC во время работы теста – 14 (для Java 8 - 26) раз.  
Кроме того, заметна ещё одна интересная особенность: распечатка демонстрирует наличие трех отдельных потоков выполнения: потока выполнения основного кода, в котором происходит генерация объектов, потока Finalizer, в котором идет выполнение методов finalize() каждого объекта, и потока, в котором работает GC. Поэтому мы видим, что распечатка строки из основного кода «SIZE OF STATIC LIST = 9842» происходит раньше последующих вызовов метода finalize() других объектов, которые пытается удалить GC (а их потом ещё примерно полторы тысячи), а также печать завершающих строк работы GC происходит вперемежку с продолжающимися вызовами метода finalize() объектов.  

**Тест №5.** Создаётся 15 тыс. объектов (для Java 8 - 3 тыс.).  
Из консольного вывода, лога GC и графика jconsole следует, что поведение теста относительно использования памяти примерно повторяет тесты №2 и №4, т.е. появление локальной ссылки в методе finalize() делает объекты достижимыми из корневого объекта и исключает их удаление GC.  
Общее количество отработок GC во время работы теста – 14 (для Java 8 - 26) раз.

**Дополнительно можно отметить следующее:**
- метод finalize() класса Object пустой и не выполняет никаких действий. Другие объекты могут переопределять это поведение;  
- метод finalize() никогда не вызывается более одного раза для любого заданного объекта;  
- если подкласс переопределяет finalize(), он должен явно вызвать финализатор суперкласса;
- метод finalize() является deprecated, начиная с Java 9.