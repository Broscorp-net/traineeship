###Переполнение численного типа

Каждая примитивная переменная имеет размерность:

* byte - 8 бит (от -128 до 127)
* short - 16 бит (от -32768 до 32767)
* int - 32 бит (от -2147483648 до 2147483647)
* long - 64 бит (от -9223372036854775808L до 9223372036854775807L)
* float - 32 бит (от 1.4e-45f до 3.4e+38f)
* double - 64 бит (от 4.9e-324 до 1.7e+308)

На примере ***byte*** я рассмотрел в тесте вопрос о переполнение. Т.к. у ***byte*** диапазон значений от -128 до 127, то при превышении 127 + 1 (в теории должно быть "128"), но в ***byte*** перекинет в нижний диапазон значения и ответом окажется -128.

###Конвертация между примитивными типами

Задание гласило что нужно рассмотреть разные случаи с конвертацией (***long -> int; float -> double***). С примерам ___long -> int___ было написано 2 теста: 
* когда значение **long** находится в диапазоне **int**;
* когда не находится соответственно.

Конвертация с плавающей точкой распишу в следующем пункте.

###Конвертация double
Два последних теста посвящены числам с плавающей точкой. Первый (из них) описывает конвертацию из ***float*** в ***double***, так как числа с плавающей точкой не имеют точного представления в двоичной системы, переход совершается с "некой не точностью".

Пример:
```java
float number = 0.1f;
double b;
b = number;
System.out.println(b); ///Ответ 0.10000000149011612
 ```
Мы видим что переход тут был совершен автоматически, но появилась не точность передачи, в виде остатка в конце. 

По этому, в тесте был применен лучший, но все равно ошибочный способ, по словам автора(каюсь не сам к этому пришел), это сравнивать разницу с допустимой абсолютной погрешностью.

По double все еще разбираю как оно устроенно в двоичной системе...