package net.broscorp.valueref;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ValuerefTest {
  @Test
  void fooTest() {
    Foo foo = new Foo();
    List<String> list = new ArrayList<>();
    int i = 1;
    foo.foo(i, list);
    Assertions.assertEquals("d", list.get(0));
    Assertions.assertEquals(i,1);
  }
  /*
  Мы можем протестировать только то, что добавиться в коллекцию, принимаемую методом foo,
  так как в эту коллекцию в методе добавиться значение.
  А значение int i, которую принимает методом foo, может использоваться только внутри
  самого метода, и даже если туда передать переменную, это ее не изменит.

   В метод foo мы передаем значение примитива, которое хранится в памяти Stack,
   приняв его внутри метода в Stack будет создана еще одна запись,
   с которой будет произведена операция внутри метода и никак не повлияет на первую запись, а
   соответственно она не изменится.
   Передав ссылку также хранящуюся в стеке, метод будет менять сам объект который находится уже
   в Куче (Heap), а если мы после этого опять воспользуемся ссылкой из стека мы попадем на уже
   измененный объект в Куче, а соответсвенно получим из него значение добавленное внутри метода.
   Как-то так, не судите строго - объяснил как смог...
   */
}
